#include <stdio.h>
#include <stdlib.h>

struct node {
  int data; //node will store some data
  struct node *right_child; // right child
  struct node *left_child; // left child
};
struct node *head = NULL, *newnode, *parentptr, *temp;
//function to create a node
struct node* new_node(int x) {
  struct node *temp;
  temp = malloc(sizeof(struct node));
  temp -> data = x;
  temp -> left_child = NULL;
  temp -> right_child = NULL;

  return temp;
}

//todo no of nodes  (recursion)--8
int totalNodes(struct node *tree)
{
    if (tree == NULL)
        return 0;
    else
        return (totalNodes(tree->left_child) + totalNodes(tree->right_child) + 1);
}
//todo External Nodes (recursion)--9
int totalExternalNodes(struct node *tree)
{
    if (tree == NULL)
        return 0;
    else if ((tree->left_child == NULL) && (tree->right_child == NULL))
        return 1;
    else
        return (totalExternalNodes(tree->left_child) + totalExternalNodes(tree->right_child));
}
//todo Internal Nodes (recursion)--10
int totalInternalNodes(struct node *tree)
{
    if ((tree == NULL) || ((tree->left_child == NULL) && (tree->right_child == NULL)))
        return 0;
    else {
   	printf("%d ",tree->data);
        return (totalInternalNodes(tree->left_child) + totalInternalNodes(tree->right_child) + 1);
        }
}
//todo Height of a Tree (recursion)-11
int Height(struct node *tree)
{
    int leftheight, rightheight;
    if (tree == NULL)
        return -1;

    leftheight = Height(tree->left_child);
    rightheight = Height(tree->right_child);

    if (leftheight > rightheight)
        return (leftheight + 1);
    else
        return (rightheight + 1);
}
//todo delete the tree (recursion)--12
void deleteTree(struct node *tree)
{
    head = NULL;
    if (tree != NULL)
    {
        deleteTree(tree->left_child);
        deleteTree(tree->right_child);
        free(tree);
    }
    else
        return;
}
// searching operation
struct node* search(struct node * root, int x) {
  if (root == NULL || root -> data == x) //if root->data is x then the element is found
    return root;
  else if (x > root -> data) // x is greater, so we will search the right subtree
    return search(root -> right_child, x);
  else //x is smaller than the data, so we will search the left subtree
    return search(root -> left_child, x);
}

// insertion
struct node* insert(struct node * root, int x) {
  //searching for the place to insert
  if (root == NULL)
    return new_node(x);
  else if (x > root -> data) // x is greater. Should be inserted to the right
    root -> right_child = insert(root -> right_child, x);
  else // x is smaller and should be inserted to left
    root -> left_child = insert(root -> left_child, x);
  return root;
}

//function to find the minimum value in a node
struct node* find_minimum(struct node * root) {
  if (root == NULL)
    return NULL;
  else if (root -> left_child != NULL) // node with minimum value will have no left child
    return find_minimum(root -> left_child); // left most element will be minimum
  return root;
}

// deletion
struct node* delete(struct node * root, int x) {
  //searching for the item to be deleted
  if (root == NULL)
    return NULL;
  if (x > root -> data)
    root -> right_child = delete(root -> right_child, x);
  else if (x < root -> data)
    root -> left_child = delete(root -> left_child, x);
  else {
    //No Child node
    if (root -> left_child == NULL && root -> right_child == NULL) {
      free(root);
      return NULL;
    }

    //One Child node
    else if (root -> left_child == NULL || root -> right_child == NULL) {
      struct node *temp;
      if (root -> left_child == NULL)
        temp = root -> right_child;
      else
        temp = root -> left_child;
      free(root);
      return temp;
    }

    //Two Children
    else {
      struct node *temp = find_minimum(root -> right_child);
      root -> data = temp -> data;
      root -> right_child = delete(root -> right_child, temp -> data);
    }
  }
  return root;
}

// Inorder Traversal
void inorder(struct node *root) {
  if (root != NULL) // checking if the root is not null
  {
    inorder(root -> left_child); // traversing left child
    printf(" %d ", root -> data); // printing data at root
    inorder(root -> right_child); // traversing right child
  }
}

int main() {
   struct node* root = NULL;
    int n, value;

    printf("Enter the number of nodes: ");
    scanf("%d", &n);

    printf("Enter the values of the nodes:\n");
    for (int i = 0; i < n; ++i) {
        scanf("%d", &value);
        root = insert(root, value);
  }

  inorder(root);
  printf("\n");
  printf("Total Nodes:%d \n",totalNodes(root));
  printf("Total External Nodes:%d \n",totalExternalNodes(root));
  totalInternalNodes(root);
  deleteTree(root);
  printf("\n");

  return 0;
}
